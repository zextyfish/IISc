/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MiniVimrc
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  vimrcPath: ".vimrc"
};
var MapMode = /* @__PURE__ */ ((MapMode2) => {
  MapMode2["nmap"] = "normal";
  MapMode2["vmap"] = "visual";
  MapMode2["imap"] = "insert";
  MapMode2["map"] = "map";
  MapMode2["unmap"] = "unmap";
  return MapMode2;
})(MapMode || {});
var MiniVimrc = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.CodeMirrorVimObj = null;
  }
  async process_vimrc() {
    if (this.vimrcPath) {
      const file = await this.read_file(this.vimrcPath);
      const lines = file.split("\n");
      this.logger(`Processing vimrc file ${lines.length.toString()} lines`);
      for (const line of lines) {
        this.process_line(line);
      }
      new import_obsidian.Notice("Vimrc loaded!");
    }
  }
  is_map(first_token) {
    return first_token in MapMode;
  }
  process_line(line) {
    const trimmed_line = line.trim();
    if (trimmed_line.startsWith('"') || trimmed_line.length == 0) {
      return;
    }
    const line_tokens = trimmed_line.split(" ");
    if (this.is_map(line_tokens[0])) {
      this.process_maps(line_tokens);
    } else {
      this.logger(`Could not process line "${line_tokens.join(" ")}". ${line_tokens[0]} is not a map or unmap command`);
    }
  }
  async read_file(path) {
    try {
      this.logger(`Attempting to read vimrc file in path "${path}"`);
      const file = await this.app.vault.adapter.read(path);
      return file.trim();
    } catch (err) {
      new import_obsidian.Notice(`Could not find the vimrc file in ${path}`);
      throw new Error(`Failed to read file ${path}`);
    }
  }
  set_vim_map(lhs, rhs, mode) {
    const cmo = this.CodeMirrorVimObj;
    this.logger(`set_vim_map: (${lhs} ${rhs} ${mode})`);
    if (mode === "map" /* map */) {
      cmo.map(lhs, rhs);
      return;
    }
    cmo.map(lhs, rhs, mode);
  }
  set_vim_unmap(lhs) {
    const cmo = this.CodeMirrorVimObj;
    this.logger(`set_vim_unmap: ${lhs}`);
    cmo.unmap(lhs);
  }
  async initialize() {
    var _a;
    if (!this.CodeMirrorVimObj) {
      this.CodeMirrorVimObj = (_a = window.CodeMirrorAdapter) == null ? void 0 : _a.Vim;
    }
    if (this.settings.vimrcPath) {
      this.logger("Custom vimrc file path set.");
      this.vimrcPath = this.settings.vimrcPath;
    } else {
      this.logger("No custom vimrc file path set. Using default.");
      this.vimrcPath = DEFAULT_SETTINGS.vimrcPath;
      this.settings.vimrcPath = DEFAULT_SETTINGS.vimrcPath;
    }
  }
  process_maps(line_tokens) {
    const mapMode = MapMode[line_tokens[0]].toString();
    const lhs = line_tokens[1];
    const rhs = line_tokens[2];
    if (mapMode === "unmap" /* unmap */) {
      this.set_vim_unmap(lhs);
      return;
    }
    if (!lhs || !rhs) {
      this.logger(`Could not map line: ${line_tokens.join(" ")}. lhs or rhs not present`);
      return;
    }
    this.set_vim_map(lhs, rhs, mapMode);
  }
  logger(message) {
    const prefix = "Mini Vimrc Plugin:";
    console.log(prefix, message);
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    await this.initialize();
    if (this.CodeMirrorVimObj) {
      await this.process_vimrc();
    }
  }
  onunload() {
    if (this.CodeMirrorVimObj) {
      this.CodeMirrorVimObj.mapclear();
      this.logger("Unloaded vimrc");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Mini Vimrc Settings" });
    const documentationUrl = "https://github.com/cabra-arretado/mini-vimrc-obsidian";
    const settingsDescription = containerEl.createDiv();
    settingsDescription.appendChild(
      createEl("span", {
        text: "See "
      })
    );
    settingsDescription.appendChild(
      createEl("a", {
        text: "documentation",
        href: documentationUrl
      })
    );
    settingsDescription.appendText(" for details.");
    containerEl.createEl("br");
    new import_obsidian.Setting(containerEl).setName("Vimrc path").setDesc("Relative path to the target vimrc file.").addText((text) => {
      text.setPlaceholder(DEFAULT_SETTINGS.vimrcPath);
      text.setValue(this.plugin.settings.vimrcPath || DEFAULT_SETTINGS.vimrcPath);
      text.onChange((value) => {
        this.plugin.settings.vimrcPath = value;
        this.plugin.saveSettings();
      });
    });
  }
};
